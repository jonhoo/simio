#
# Paxos IO Automata
#

Name:
	Paxos

Signature-Input:
	# Leader
	recv_ack(m)
	# Other
	proposal(m)
	decide(m)

Signature-Output:
	# Leader
	prepare(m) connect proposal
	accept(m) connect decide
	# Other
	ack(m) connect recv_ack

State:
	import random

	# For all nodes
	self.sendq = {n: [] for n in self.nbrs}
	self.accepted = (0, None)

	# For leaders in phase 1
	self.ballot = random.random()
	self.value = random.random()
	self.enlisted = []

	# For leaders in phase 2
	self.votes = 0

	# For leaders in phase 3
	self.won = []

# Leader asks node to vote for proposed value
Transition-Name:
	prepare(m)
Transition-Precondition:
	return to not in self.enlisted
Transition-Output:
	self.enlisted.push(to)
	return self.ballot

# Leader asks node to accept value
Transition-Name:
	accept(m)
Transition-Precondition:
	return self.votes > N/2 and to not in self.won
Transition-Output:
	self.won.push(to)
	return (self.ballot, self.value)

# Node sends ack to leader
Transition-Name:
	ack(m)
Transition-Precondition:
	return len(self.sendq[to]) > 0
Transition-Output:
	return self.sendq[to][0]
Transition-Effect:
	self.sendq[to].popleft()

# Leader receives ack from node
Transition-Name:
	recv_ack(m)
Transition-Effect:
	self.votes = self.votes + 1
	if m[1] is not None:
		self.accepted[1] = m[1]

# Node receives proposal from leader
Transition-Name:
	proposal(m)
Transition-Effect:
	if m > self.accepted[0]:
		self.accepted[0] = m
		sendq[fr].push(m, self.accepted[1], self.accepted[0])

# Node receives decision from leader
Transition-Name:
	decide(m)
Transition-Effect:
	if m[0] > self.accepted[0]:
		print "%d accepted value %d" % (self.i, self.accepted[1])
		# Indicate that we're done
		self.markcb("green")

Tasks:
	prepare(m)
	accept(m)
	ack(m)
